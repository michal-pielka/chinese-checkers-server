
File path: java/org/example/Server/UserSession.java:
package org.example.Server;

import org.example.Game.Game;
import org.example.Game.GameRules.GameRules;
import org.example.Game.GameRules.StdRules;
import org.example.Game.GameRules.SuperRules;
import org.example.Game.Player;
import org.example.Server.States.UserState;
import org.example.Server.States.LobbyState;
import org.example.Server.States.InGameState;

import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Encapsulates the game-related logic, state transitions, 
 * and user interactions (prompts) for a single connected user.
 */
public class UserSession {
    private final Server server;
    private final PrintWriter outputWriter;
    private final Scanner inputReader;
    private final Player player;

    // The user's current state (Lobby, InGame, etc.)
    private UserState state;

    // Flag to indicate if the session is active
    private volatile boolean active;

    /**
     * Constructor
     *
     * @param server       The server instance for game lookups, etc.
     * @param outputWriter A PrintWriter for sending messages to the client.
     * @param inputReader  A Scanner for reading user input.
     */
    public UserSession(Server server, PrintWriter outputWriter, Scanner inputReader) {
        this.server = server;
        this.outputWriter = outputWriter;
        this.inputReader = inputReader;
        this.state = new LobbyState(); // Initial state
        this.player = new Player("defaultName", outputWriter);
        this.active = true; // Session starts as active
    }

    /**
     * Handles the command from the client, delegating to the current state.
     *
     * @param clientInput The raw command string.
     */
    public void handleCommand(String clientInput) {
        System.out.println("Handling command: " + clientInput);
        state.handleCommand(this, clientInput);
    }

    /**
     * Sends a message to the client's console.
     *
     * @param message The message to send.
     */
    public void sendMessage(String message) {
        outputWriter.println(message);
        System.out.println("Sent message to " + player.getName() + ": " + message);
    }

    /**
     * Updates the user's state.
     *
     * @param newState The new state to set.
     */
    public void setState(UserState newState) {
        System.out.println("Transitioning user " + player.getName() + " from " 
                           + state.getClass().getSimpleName() + " to " 
                           + newState.getClass().getSimpleName());
        this.state = newState;
    }

    /**
     * Gets the currently logged-in Player instance.
     */
    public Player getPlayer() {
        return player;
    }

    /**
     * Gets the Server reference for game lookups, game creation, etc.
     */
    public Server getServer() {
        return server;
    }

    /**
     * Gets the current state of the user.
     */
    public UserState getState() {
        return this.state;
    }

    // ----------------------------------------------------------------------
    // Methods to facilitate user interactions (now called by Command classes)
    // ----------------------------------------------------------------------

    public String askForLobbyName() {
        String lobbyName = null;
        while (lobbyName == null || lobbyName.isEmpty()) {
            sendMessage("Please input your lobby name:");
            if (inputReader.hasNextLine()) {
                lobbyName = inputReader.nextLine().trim();
                if (lobbyName.isEmpty()) {
                    sendMessage("Lobby name cannot be empty.");
                    System.out.println("User " + player.getName() + " entered an empty lobby name.");
                }
            } else {
                lobbyName = "default_lobby";
                System.out.println("No lobby name input detected. Defaulting to 'default_lobby'.");
            }
        }
        return lobbyName;
    }

    public GameRules askForGameVariant() {
        String gameVariant = null;
        while (gameVariant==null || (!gameVariant.equals("std") && !gameVariant.equals("super"))) {
            sendMessage("Please input 'Std' for standard game variant or 'Super' for super game variant.");
            if(inputReader.hasNextLine()) {
                gameVariant = inputReader.nextLine().trim().toLowerCase();
            }
            else {
                gameVariant = "std";
                System.out.println("No game variant detected. Defaulting to Standard Game Variant.");
            }
        }
        if(gameVariant.equals("super")) {
            return new SuperRules();
        }
        return new StdRules();
    }

    /**
     * Sends the initial welcome/help menu to the client.
     */
    public void displayStartMenu() {
        sendMessage("Welcome! Use one of the following commands: join, create, list, quit");
    }

    public int askForNumberOfPlayers() {
        int number = 0;
        while (number != 2 && number != 3 && number != 4 && number != 6) {
            sendMessage("Please input number of players (2, 3, 4, or 6):");
            if (inputReader.hasNextLine()) {
                String response = inputReader.nextLine().trim();
                try {
                    number = Integer.parseInt(response);
                    if (number != 2 && number != 3 && number != 4 && number != 6) {
                        sendMessage("Invalid number of players. Choose 2, 3, 4, or 6.");
                        System.out.println("User " + player.getName() + " entered invalid number of players: " + number);
                    }
                } catch (NumberFormatException e) {
                    sendMessage("Invalid input. Please enter a numeric value.");
                    System.out.println("User " + player.getName() + " entered non-numeric input for number of players.");
                }
            } else {
                // Fallback
                sendMessage("No input detected. Defaulting to 2 players.");
                number = 2;
                System.out.println("No input detected for number of players. Defaulting to 2.");
            }
        }
        return number;
    }

    public String askForPlayerName() {
        String playerName = null;
        while (playerName == null || playerName.isEmpty()) {
            sendMessage("Please input your player name:");
            if (inputReader.hasNextLine()) {
                playerName = inputReader.nextLine().trim();
                if (playerName.isEmpty()) {
                    sendMessage("Player name cannot be empty.");
                    System.out.println("User " + player.getName() + " entered an empty player name.");
                }
            } else {
                playerName = "Anonymous";
                System.out.println("No player name input detected. Defaulting to 'Anonymous'.");
            }
        }
        return playerName;
    }

    /**
     * Signals the session to terminate.
     */
    public void terminate() {
        this.active = false;
        System.out.println("Session for user " + player.getName() + " is marked for termination.");
    }

    /**
     * Checks if the session is active.
     *
     * @return True if active, false otherwise.
     */
    public boolean isActive() {
        return active;
    }
}

File path: java/org/example/Server/UserThread.java:
package org.example.Server;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

/**
 * Handles communication with a single client.
 */
public class UserThread implements Runnable {
    private final Socket socket;
    private final Server server;
    private Scanner inputReader;
    private PrintWriter outputWriter;

    private UserSession userSession;
    private final UserManager userManager;

    /**
     * Constructor to initialize client socket and server reference.
     *
     * @param socket The client socket.
     * @param server The server instance managing games.
     */
    public UserThread(Socket socket, Server server) {
        this.socket = socket;
        this.server = server;
        this.userManager = new UserManager(server);

        try {
            initializeStreams();
            this.userSession = userManager.createUserSession(outputWriter, inputReader);

        } catch (IOException e) {
            System.err.println("Error initializing I/O streams for client " + socket + ": " + e.getMessage());
            closeSocket();
        }
    }

    /**
     * Initializes the input and output streams for communication with the client.
     *
     * @throws IOException If an I/O error occurs.
     */
    private void initializeStreams() throws IOException {
        inputReader = new Scanner(socket.getInputStream());
        outputWriter = new PrintWriter(socket.getOutputStream(), true);
    }

    /**
     * Entry point for the user thread.
     */
    @Override
    public void run() {
        System.out.println("Connected: " + socket);

        try {
            userSession.displayStartMenu();

            while (inputReader.hasNextLine()) {
                String clientInput = inputReader.nextLine().trim();
                System.out.println("Received from " + socket + ": " + clientInput);

                userSession.handleCommand(clientInput);
            }

        } catch (Exception e) {
            System.err.println("Error communicating with client " + socket + ": " + e.getMessage());

        } finally {
            closeSocket();
            System.out.println("Closed: " + socket);
        }
    }

    /**
     * Closes the client socket gracefully.
     */
    private void closeSocket() {
        try {
            if (socket != null && !socket.isClosed()) {
                socket.close();
            }
        } catch (IOException e) {
            System.err.println("Error closing socket " + socket + ": " + e.getMessage());
        }
    }
}

File path: java/org/example/Server/UserManager.java:
// File path: src/main/java/org/example/Server/UserManager.java
package org.example.Server;

import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Manages user sessions, creation, and related functionalities.
 */
public class UserManager {
    private final Server server;

    /**
     * Constructor to initialize the UserManager with a reference to the Server.
     *
     * @param server The server instance managing games.
     */
    public UserManager(Server server) {
        this.server = server;
    }

    /**
     * Creates a new UserSession.
     *
     * @param outputWriter The PrintWriter to send messages to the client.
     * @param inputReader  The Scanner to read user input.
     * @return A new UserSession instance.
     */
    public UserSession createUserSession(PrintWriter outputWriter, Scanner inputReader) {
        return new UserSession(server, outputWriter, inputReader);
    }

    // Additional management methods can be added here if needed in the future
}

File path: java/org/example/Server/Server.java:
package org.example.Server;

import org.example.Game.Game;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Encapsulates the core server logic.
 */
public class Server {
    private int port;
    private int threadPoolSize;
    private ExecutorService pool;
    private final List<Game> games;

    /**
     * Constructor to initialize server settings.
     *
     * @param port            The port on which the server listens.
     * @param threadPoolSize  The number of threads in the pool.
     */
    public Server(int port, int threadPoolSize) {
        this.port = port;
        this.threadPoolSize = threadPoolSize;
        this.pool = Executors.newFixedThreadPool(threadPoolSize);
        // Initialize a thread-safe list for games
        this.games = Collections.synchronizedList(new ArrayList<>());
    }

    /**
     * Starts the server to listen for client connections.
     *
     * @throws IOException If an I/O error occurs when opening the socket.
     */
    public void start() throws IOException {
        System.out.println("Server is running on port " + port + "...");

        try (ServerSocket serverSocket = new ServerSocket(port)) {
            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("New client connected: " + clientSocket);

                // Pass the server reference to UserThread
                UserThread user = new UserThread(clientSocket, this);
                pool.execute(user);
            }

        } finally {
            shutdownPool();
        }
    }

    /**
     * Shuts down the thread pool gracefully.
     */
    private void shutdownPool() {
        if (pool != null && !pool.isShutdown()) {
            pool.shutdown();
            System.out.println("Server thread pool shut down.");
        }
    }

    /**
     * Finds a game by its lobby name (case-insensitive).
     *
     * @param lobbyName The name of the lobby to find.
     * @return The Game object if found; otherwise, null.
     */
    public Game findGameByName(String lobbyName) {
        synchronized (games) {
            for (Game game : games) {
                if (game.getLobbyName().equalsIgnoreCase(lobbyName)) {
                    return game;
                }
            }
        }
        return null;
    }

    /**
     * Adds a new game to the list.
     *
     * @param game The Game object to add.
     */
    public void addGame(Game game) {
        synchronized (games) {
            games.add(game);
            System.out.println("Game added: " + game.getLobbyName());
        }
    }

    /**
     * Retrieves an unmodifiable list of current games.
     *
     * @return A list of Game objects.
     */
    public List<Game> getGames() {
        synchronized (games) {
            return Collections.unmodifiableList(new ArrayList<>(games));
        }
    }

    /**
     * Removes a game from the list.
     *
     * @param game The Game object to remove.
     */
    public void removeGame(Game game) {
        synchronized (games) {
            games.remove(game);
            System.out.println("Game removed: " + game.getLobbyName());
        }
    }
}

File path: java/org/example/Server/RunServer.java:
package org.example.Server;

import java.io.IOException;

/**
 * Entry point for the server application.
 */
public class RunServer {
    private static final int PORT = 59899;
    private static final int THREAD_POOL_SIZE = 20; // Adjust based on expected load

    public static void main(String[] args) {
        try {
            Server server = new Server(PORT, THREAD_POOL_SIZE);
            server.start();

        } catch (IOException e) {
            System.err.println("Failed to start the server: " + e.getMessage());
        }
    }
}

File path: java/org/example/Server/States/InGameState.java:
// File path: src/main/java/org/example/Server/States/InGameState.java
package org.example.Server.States;

import org.example.Server.UserSession;
import org.example.Game.Game;
import org.example.Server.Commands.CommandRegistry;
import org.example.Server.Commands.Command;
import org.example.Server.Commands.CommandConstants;

import java.util.HashMap;

public class InGameState extends UserState {
    private Game game;
    private CommandRegistry registry;

    public InGameState(Game game) {
        this.game = game;
        this.registry = new CommandRegistry();
        this.commands = new HashMap<>();

        commands.put(CommandConstants.MOVE, registry.getCommand(CommandConstants.MOVE));
    }

    @Override
    public void handleCommand(UserSession session, String commandLine) {
        String[] tokens = commandLine.split("\\s+");
        String commandName = tokens[0].toLowerCase();
        Command command = commands.get(commandName);

        if (command != null) {
            command.execute(session, tokens);

        } else {
            session.sendMessage("Invalid command in Game. Available commands: move");
        }
    }

    public Game getGame() {
        return this.game;
    }
}

File path: java/org/example/Server/States/UserState.java:
package org.example.Server.States;

import org.example.Server.UserSession;
import org.example.Server.Commands.Command;

import java.util.HashMap;

public abstract class UserState {
    protected HashMap<String, Command> commands;

    public abstract void handleCommand(UserSession session, String commandLine);
}

File path: java/org/example/Server/States/LobbyState.java:
// File path: src/main/java/org/example/Server/States/LobbyState.java
package org.example.Server.States;

import org.example.Server.UserSession;
import org.example.Server.Commands.CommandRegistry;
import org.example.Server.Commands.Command;
import org.example.Server.Commands.CommandConstants;

import java.util.HashMap;

public class LobbyState extends UserState {
    private CommandRegistry registry;

    public LobbyState() {
        this.registry = new CommandRegistry();
        this.commands = new HashMap<>();

        // Load lobby-specific commands using constants
        commands.put(CommandConstants.JOIN, registry.getCommand(CommandConstants.JOIN));
        commands.put(CommandConstants.CREATE, registry.getCommand(CommandConstants.CREATE));
        commands.put(CommandConstants.LIST, registry.getCommand(CommandConstants.LIST));
        commands.put(CommandConstants.QUIT, registry.getCommand(CommandConstants.QUIT));
    }

    @Override
    public void handleCommand(UserSession session, String commandLine) {
        String[] tokens = commandLine.split("\\s+");
        String commandName = tokens[0].toLowerCase();
        Command command = commands.get(commandName);
        if (command != null) {
            command.execute(session, tokens);
        } else {
            session.sendMessage("Invalid command in Lobby. Available commands: join, create, list, quit");
        }
    }
}

File path: java/org/example/Server/Commands/CreateCommand.java:
package org.example.Server.Commands;

import org.example.Game.Board.StdBoard;
import org.example.Game.GUI.BoardDisplay;
import org.example.Game.Game;
import org.example.Game.GameRules.GameRules;
import org.example.Game.GameRules.StdRules;
import org.example.Game.GameRules.SuperRules;
import org.example.Server.States.InGameState;
import org.example.Server.UserSession;

public class CreateCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        System.out.println("User " + session.getPlayer().getName() + " chose to create a game.");
        session.sendMessage("You chose to create a game.");

        String lobbyName = session.askForLobbyName();
        if (session.getServer().findGameByName(lobbyName) != null) {
            session.sendMessage("A game with lobby name '" + lobbyName + "' already exists. Try a different name.");
            System.out.println("User " + session.getPlayer().getName() + " attempted to create a lobby with existing name '" + lobbyName + "'.");
            return;
        }

        int maxPlayers = session.askForNumberOfPlayers();

        GameRules gameVariant = session.askForGameVariant();

        Game game = new Game(lobbyName, maxPlayers, new StdBoard(maxPlayers), gameVariant);


        session.getServer().addGame(game);
        System.out.println("User " + session.getPlayer().getName() + " created game '" + lobbyName + "', max players: " + maxPlayers);

        String playerName = session.askForPlayerName();
        session.getPlayer().setName(playerName);
        System.out.println("User set name to " + playerName);

        game.addPlayer(session.getPlayer());
        game.broadcastMessage(session.getPlayer().getName() + " has created and joined the game.");
        System.out.println("User " + session.getPlayer().getName() + " joined their own created game '" + lobbyName + "'.");

        // Switch to InGameState
        session.setState(new InGameState(game));
    }
}

File path: java/org/example/Server/Commands/JoinCommand.java:
package org.example.Server.Commands;

import org.example.Game.GUI.BoardDisplay;
import org.example.Game.Game;
import org.example.Server.States.InGameState;
import org.example.Server.UserSession;

public class JoinCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        System.out.println("User " + session.getPlayer().getName() + " chose to join a game.");
        session.sendMessage("You chose to join a game.");

        String playerName = session.askForPlayerName();
        session.getPlayer().setName(playerName);
        System.out.println("User set name to " + playerName);

        // Attempt to find the requested lobby
        Game game = null;
        while (game == null) {
            String lobbyName = session.askForLobbyName();
            game = session.getServer().findGameByName(lobbyName);
            if (game == null) {
                session.sendMessage("Cannot find game with lobby name '" + lobbyName + "'. Try again.");
                System.out.println("User " + session.getPlayer().getName() + " attempted to join non-existent lobby '" + lobbyName + "'.");
            }
        }

        // Join the game
        synchronized (game) {
            if (game.getPlayers().size() >= game.getMaxPlayers()) {
                session.sendMessage("Game '" + game.getLobbyName() + "' is full. Choose another game.");
                System.out.println("User " + session.getPlayer().getName() + " attempted to join full lobby '" + game.getLobbyName() + "'.");
                return;
            }
            game.addPlayer(session.getPlayer());
            game.broadcastMessage(session.getPlayer().getName() + " has joined the game.");
            System.out.println("User " + session.getPlayer().getName() + " joined game '" + game.getLobbyName() + "'.");

            // Transition to InGameState
            session.setState(new InGameState(game));
        }
    }
}

File path: java/org/example/Server/Commands/ListGamesCommand.java:
package org.example.Server.Commands;

import org.example.Game.GameRules.GameRules;
import org.example.Game.GameRules.StdRules;
import org.example.Game.GameRules.SuperRules;
import org.example.Server.UserSession;
import org.example.Game.Game;

import java.util.List;

public class ListGamesCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        System.out.println("User " + session.getPlayer().getName() + " requested to list available games.");
        List<Game> currentGames = session.getServer().getGames();
        
        if (currentGames.isEmpty()) {
            session.sendMessage("No available games to join. You can create one using the 'create' command.");
            System.out.println("No available games found for user " + session.getPlayer().getName() + ".");
        } else {
            session.sendMessage("Available Games:");
            for (Game g : currentGames) {
                session.sendMessage("- " + g.getLobbyName() + " (" 
                                    + g.getPlayers().size() + "/" 
                                    + g.getMaxPlayers() + " players, variant: "
                                    + GameRulesToString(g.getRules())+ ")");
            }
            System.out.println("Listed " + currentGames.size() + " available games to user " + session.getPlayer().getName() + ".");
        }
    }

    private String GameRulesToString(GameRules rules) {
        if(rules instanceof StdRules) {
            return "Standard";
        }
        if(rules instanceof SuperRules) {
            return "Super";
        }
        return "Unknown";
    }
}

File path: java/org/example/Server/Commands/Command.java:
package org.example.Server.Commands;

import org.example.Server.UserSession;

public interface Command {
    void execute(UserSession session, String[] args);
}

File path: java/org/example/Server/Commands/QuitCommand.java:
package org.example.Server.Commands;

import org.example.Server.UserSession;

/**
 * Handles the 'quit' command, allowing the user to disconnect gracefully.
 */
public class QuitCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        System.out.println("User " + session.getPlayer().getName() + " is disconnecting.");
        session.sendMessage("Disconnecting from the server. Goodbye!");

        // Signal the session to terminate
        session.terminate();
    }
}

File path: java/org/example/Server/Commands/CommandRegistry.java:
package org.example.Server.Commands;

import java.util.HashMap;
import java.util.Map;

public class CommandRegistry {
    private Map<String, Command> commands = new HashMap<>();

    public CommandRegistry() {
        register(CommandConstants.JOIN, new JoinCommand());
        register(CommandConstants.CREATE, new CreateCommand());
        register(CommandConstants.LIST, new ListGamesCommand());
        register(CommandConstants.QUIT, new QuitCommand());
        register(CommandConstants.MOVE, new MoveCommand());
    }

    public void register(String commandName, Command command) {
        commands.put(commandName, command);
    }

    public Command getCommand(String commandName) {
        return commands.get(commandName);
    }
}

File path: java/org/example/Server/Commands/CommandConstants.java:
package org.example.Server.Commands;

/**
 * Holds all command string constants used in the server.
 */
public class CommandConstants {
    public static final String CREATE = "create";
    public static final String JOIN = "join";
    public static final String LIST = "list";
    public static final String QUIT = "quit";
    public static final String MOVE = "move";
}

File path: java/org/example/Server/Commands/MoveCommand.java:
package org.example.Server.Commands;

import org.example.Server.UserSession;
import org.example.Game.Game;

public class MoveCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        if (args.length != 3) {
            session.sendMessage("Usage: move <x1:y1> <x2:y2>");
            return;
        }
        try {
            String startPos = args[1];
            String endPos = args[2];
            Game game = ((org.example.Server.States.InGameState) session.getState()).getGame();
            try {
                int x1,y1,x2,y2;

                String[] parts1= startPos.split(":");
                x1 = Integer.parseInt(parts1[0]);
                y1 = Integer.parseInt(parts1[1]);

                String[] parts2 = endPos.split(":");
                x2 = Integer.parseInt(parts2[0]);
                y2 = Integer.parseInt(parts2[1]);
                game.move(session.getPlayer(), x1, y1, x2, y2);
            }
            catch(NumberFormatException e) {
                session.sendMessage("Start and End positions should be in format 'x:y'");
            }

        } catch (NumberFormatException e) {
            session.sendMessage("Start and End positions should be in format 'x:y'");
        } catch (ClassCastException e) {
            session.sendMessage("Invalid game state for moving.");
            System.out.println("User " + session.getPlayer().getName() + " attempted to move in an invalid state.");
        }
    }
}

File path: java/org/example/Game/Player.java:
package org.example.Game;

import java.io.PrintWriter;

/**
 * Represents a player in the game.
 */
public class Player {
    private PrintWriter outputWriter;
    private String playerName;

    /**
     * Constructs a new Player with the specified name.
     *
     * @param name the name of the player
     * @param writer the outputWriter for the player
     */
    public Player(String name, PrintWriter writer) {
        this.playerName = name;
        this.outputWriter = writer;
    }

    /**
     * Sends a message to the player.
     *
     * @param message the message to send
     */
    public void sendMessage(String message) {
        outputWriter.println(message);
    }

    /**
     * Gets the player's name.
     *
     * @return the name of the player
     */
    public String getName() {
        return playerName;
    }

    /**
     * Sets the player's name.
     *
     * @param name the name of the player
     */
    public void setName(String name) {this.playerName = name;}
}

File path: java/org/example/Game/Game.java:
package org.example.Game;

import org.example.Game.Board.Board;
import org.example.Game.GameRules.GameRules;
import org.example.Game.GameState.GameState;
import org.example.Game.GameState.WaitingForPlayers;
import java.util.ArrayList;

/**
 * Represents a game session, managing players, the board, game rules, and state transitions.
 */
public class Game {
    String lobbyName;
    ArrayList<Player> players;
    int currentPlayer;
    int maxPlayers;
    Board board;
    GameState state;
    GameRules rules;

    /**
     * Constructs a new Game instance.
     *
     * @param name        the name of the game lobby
     * @param playerCount the maximum number of players
     * @param board       the game board
     * @param rules       the rules of the game
     */
    public Game(String name, int playerCount, Board board, GameRules rules) {
        this.lobbyName = name;
        this. maxPlayers = playerCount;
        players = new ArrayList<>();
        this.board = board;
        state = new WaitingForPlayers();
        this.rules = rules;
        currentPlayer = 0;
    }

    /**
     * Gets the name of the game lobby.
     *
     * @return the lobby name
     */
    public String getLobbyName() {
        return lobbyName;
    }

    /**
     * Gets the list of players in the game.
     *
     * @return the list of players
     */
    public ArrayList<Player> getPlayers() {
        return players;
    }

    /**
     * Gets the index of the current player.
     *
     * @return the current player's index
     */
    public int getCurrentPlayer() {
        return currentPlayer;
    }

    /**
     * Sets the current player by index.
     *
     * @param i the index of the current player
     */
    public void setCurrentPlayer(int i) {
        this.currentPlayer = i % this.maxPlayers;
    }

    /**
     * Gets the maximum number of players allowed in the game.
     *
     * @return the maximum number of players
     */
    public int getMaxPlayers() {
        return maxPlayers;
    }

    /**
     * Sets the current game state.
     *
     * @param state the new game state
     */
    public void setState(GameState state) {
        this.state = state;
    }

    /**
     * Gets the current game state.
     *
     * @return the current game state
     */
    public GameState getState() {
        return state;
    }

    /**
     * Adds a player to the game.
     *
     * @param player the player to add
     */
    public void addPlayer(Player player) {
        state.addPlayer(this, player);
    }

    /**
     * Sends a message to all players in the game.
     *
     * @param message the message to broadcast
     */
    public void broadcastMessage(String message) {
        for(Player player : players) {
            player.sendMessage(message);
        }
    }

    /**
     * Gets the game board.
     *
     * @return the game board
     */
    public Board getBoard() { return board; }

    /**
     * Gets the game rules.
     *
     * @return the game rules
     */
    public GameRules getRules() {return rules; }

    /**
     * Processes a move attempt by a player.
     *
     * @param player the player attempting the move
     * @param x1     the starting x-coordinate
     * @param y1     the starting y-coordinate
     * @param x2     the ending x-coordinate
     * @param y2     the ending y-coordinate
     */
    public void move(Player player, int x1, int y1, int x2, int y2) {
        if(players.get(currentPlayer) != player) {
            player.sendMessage("Not your turn.");
        }
        else {
            state.play(this, x1, y1, x2, y2);
        }
    }

    /**
     * Ends the current player's turn and advances to the next player.
     */
    public void endTurn() {
        currentPlayer=(currentPlayer + 1) % maxPlayers;
    }
}

File path: java/org/example/Game/GameRules/SuperRules.java:
package org.example.Game.GameRules;

import org.example.Game.Board.Board;
import org.example.Game.Board.Node;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class SuperRules implements GameRules{

    public boolean lineClear(Board board, int dx, int dy, int startX, int startY, int endX, int endY) {
        int checkX = startX + dx;
        int checkY = startY + dy;
        while(checkX != endX || checkY != endY) {
            if(board.getNode(checkX+":"+checkY).getPlayer() != 0) {
                return false;
            }
            checkX += dx;
            checkY += dy;
        }
        return true;
    }

    public Set<String> findJumps(Board board, int x, int y, Set<String> visited) {
        String currKey = x+":"+y;
        visited.add(currKey);

        int[] directionsX = {0, 1, 1, 0, -1, -1};
        int[] directionsY = {1, 1, 0, -1, -1, 0};

        for(int i=0 ; i<6; i++) {
            int dx = directionsX[i];
            int dy = directionsY[i];

            int midX = x + dx;
            int midY = y + dy;
            Node midNode;
            int jumpX = x + 2*dx;
            int jumpY = y + 2*dy;
            Node jumpNode;

            boolean foundOne = false;
            while(board.containsNode(jumpX+":"+jumpY) && !foundOne) {
                midNode = board.getNode(midX +":"+midY);
                jumpNode = board.getNode(jumpX+":"+jumpY);
                if(midNode.getPlayer() != 0) {
                    foundOne = true;
                    if(lineClear(board,dx,dy,midX,midY,jumpX,jumpY) && jumpNode.getPlayer() == 0 && !visited.contains(jumpX+":"+jumpY)) {
                        visited.add(jumpX+":"+jumpY);
                        findJumps(board, jumpX, jumpY, visited);
                    }
                }

                midX += dx;
                midY += dy;

                jumpX += 2*dx;
                jumpY += 2*dy;
            }
        }

        return visited;
    }

    @Override
    public boolean isMoveValid(Board board, int player, int x1, int y1, int x2, int y2) {
        String key1 = x1 + ":" + y1;
        String key2 = x2 + ":" + y2;
        Node node1, node2;

        if(board.containsNode(key1) && board.containsNode(key2)) {
            node1 = board.getNode(key1);
            node2 = board.getNode(key2);
            if(node1.getPlayer() != player) {
                return false;
            }
            if(board.inTargetBase(player, key1) && !board.inTargetBase(player, key2)) {
                return false;
            }

            if(node1.neighbours.contains(node2) && node2.getPlayer()==0) {
                return true;
            }
            else {
                Set<String> possibleJumps = findJumps(board, x1, y1, new HashSet<>());
                return possibleJumps.contains(key2);
            }
        }
        return false;
    }

    @Override
    public boolean checkForWin(Board board, int player) {
        List<String> targetBase = board.getTargetBase(player);
        for(String key: targetBase) {
            if(board.getNode(key).getPlayer() != player) {
                return false;
            }
        }
        return true;
    }
}

File path: java/org/example/Game/GameRules/StdRules.java:
package org.example.Game.GameRules;

import org.example.Game.Board.Board;
import org.example.Game.Board.Node;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * Standard implementation of the game rules.
 * Handles validation of moves and determines winning conditions.
 */
public class StdRules implements GameRules{

    /**
     * Finds all valid jump destinations from the given starting node.
     *
     * @param board the game board.
     * @param x X position of starting node.
     * @param y Y position of starting node
     * @param visited nodes already visited (new HashSet<> for default usage).
     * @return a set of nodes that can be jumped to.
     */
    public Set<String> findJumps(Board board, int x, int y, Set<String> visited) {
        String currKey = x + ":" + y;
        visited.add(currKey);

        Node currNode = board.getNode(currKey);

        for(Node neighbour : currNode.neighbours) {
            if(neighbour.getPlayer() != 0) {
                int jumpX = 2 * (neighbour.getX() - x) + x;
                int jumpY = 2 * (neighbour.getY() - y) + y;
                String jumpKey = jumpX + ":" + jumpY;

                if(board.containsNode(jumpKey)) {
                    if(board.getNode(jumpKey).getPlayer() == 0 && !visited.contains(jumpKey)) {
                        visited.add(jumpKey);
                        findJumps(board, jumpX, jumpY, visited);
                    }
                }
            }
        }
        return visited;
    }

    @Override
    public boolean isMoveValid(Board board, int player, int x1, int y1, int x2, int y2) {
        String key1 = x1 + ":" + y1;
        String key2 = x2 + ":" + y2;
        Node node1, node2;

        if(board.containsNode(key1) && board.containsNode(key2)) {
            node1 = board.getNode(key1);
            node2 = board.getNode(key2);
            if(node1.getPlayer() != player) {
                return false;
            }
            if(board.inTargetBase(player, key1) && !board.inTargetBase(player, key2)) {
                return false;
            }

            if(node1.neighbours.contains(node2) && node2.getPlayer()==0) {
                return true;
            }
            else {
                Set<String> possibleJumps = findJumps(board, x1, y1, new HashSet<>());
                return possibleJumps.contains(key2);
            }
        }
        return false;
    }

    @Override
    public boolean checkForWin(Board board, int player) {
        List<String> targetBase = board.getTargetBase(player);
        for(String key: targetBase) {
            if(board.getNode(key).getPlayer() != player) {
                return false;
            }
        }
        return true;
    }
}

File path: java/org/example/Game/GameRules/GameRules.java:
package org.example.Game.GameRules;

import org.example.Game.Board.Board;

/**
 * Defines the rules for the game.
 * Implementations of this interface determine the validity of moves and check for winning conditions.
 */
public interface GameRules {

    /**
     * Validates whether a move is legal according to the game rules.
     *
     * @param board  the game board on which the move is being made.
     * @param player the player attempting the move.
     * @param x1     the x-coordinate of the starting position.
     * @param y1     the y-coordinate of the starting position.
     * @param x2     the x-coordinate of the destination position.
     * @param y2     the y-coordinate of the destination position.
     * @return true if the move is valid, false otherwise.
     */
    boolean isMoveValid(Board board, int player, int x1, int y1, int x2, int y2);

    /**
     * Checks if the specified player has met the winning conditions.
     *
     * @param board  the game board.
     * @param player the player to check for a win.
     * @return true if the player has won, false otherwise.
     */
    boolean checkForWin(Board board, int player);
}

File path: java/org/example/Game/Board/Node.java:
package org.example.Game.Board;

import javafx.beans.property.IntegerProperty;
import javafx.beans.property.SimpleIntegerProperty;

import java.util.ArrayList;
import java.util.List;

/**
 * Represents a node on the game board.
 * Each node has coordinates, a player, a base assignment, and connections to neighboring nodes.
 */
public class Node {
     private final int x;
     private final int y;
     private final IntegerProperty player;
     public List<Node> neighbours;

    /**
     * Constructs a node with the specified coordinates.
     *
     * @param x the x-coordinate of the node.
     * @param y the y-coordinate of the node.
     */
    public Node(int x, int y) {
        this.x = x;
        this.y = y;
        this.neighbours = new ArrayList<>();
        this.player = new SimpleIntegerProperty(0);
    }

    /**
     * Adds a neighboring node to this node.
     *
     * @param neighbour the neighboring node to add.
     */
    public void addNeighbour(Node neighbour) {
        if(!neighbours.contains(neighbour)) {
            neighbours.add(neighbour);
        }
    }

    /**
     * Sets the ID of the player occupying this node.
     *
     * @param x the ID of the player (0 if unoccupied).
     */
    public void setPlayer(int x) {
        this.player.set(x);
    }

    /**
     * Retrieves the ID of the player currently occupying this node.
     *
     * @return the player ID (0 if unoccupied).
     */
    public int getPlayer() {
        return player.get();
    }

    public IntegerProperty playerProperty() {
        return player;
    }
    /**
     * Retrieves the x-coordinate of this node.
     *
     * @return the x-coordinate.
     */
    public int getX() {
        return x;
    }

    /**
     * Retrieves the y-coordinate of this node.
     *
     * @return the y-coordinate.
     */
    public int getY() {
        return y;
    }
}

File path: java/org/example/Game/Board/Graph.java:
package org.example.Game.Board;

import java.util.HashMap;
import java.util.Map;

/**
 * Represents a graph structure for the game board.
 * Manages nodes and their connections.
 */
public class Graph {
    Map<String, Node> nodes;

    /**
     * Constructs an empty graph.
     */
    public Graph() {
        nodes = new HashMap<>();
    }

    /**
     * Adds a node to the graph at the specified coordinates.
     *
     * @param x the x-coordinate of the node.
     * @param y the y-coordinate of the node.
     */
    public void addNode(int x, int y) {
        String key = getKey(x, y);

        if(!nodes.containsKey(key)) {
            Node newNode = new Node(x,y);
            nodes.put(key, newNode);
            newNode.setPlayer(0);
        }
    }

    /**
     * Retrieves a node by its key.
     *
     * @param key the key of the node in the format "x:y".
     * @return the {@link Node} object, or null if it does not exist.
     */
    public Node getNode(String key) {
       return nodes.getOrDefault(key, null);
    }

    /**
     * Checks if a node exists in the graph at the specified key.
     *
     * @param key the key representing the node (format: "x:y").
     * @return true if the node exists, false otherwise.
     */
    public boolean containsNode(String key) {
        return nodes.containsKey(key);
    }

    /**
     * Adds an undirected edge between two nodes in the graph.
     * If either node does not exist, the edge is not added.
     *
     * @param x1 the x-coordinate of the first node.
     * @param y1 the y-coordinate of the first node.
     * @param x2 the x-coordinate of the second node.
     * @param y2 the y-coordinate of the second node.
     */
    public void addEdge(int x1, int y1, int x2, int y2) {
        String key1 = getKey(x1, y1);
        String key2 = getKey(x2, y2);
        if(nodes.containsKey(key1) && nodes.containsKey(key2)) {
            nodes.get(key1).addNeighbour(nodes.get(key2));
            nodes.get(key2).addNeighbour(nodes.get(key1));
        }
    }

    /**
     * Generates a unique key for a node based on its coordinates.
     *
     * @param x the x-coordinate of the node.
     * @param y the y-coordinate of the node.
     * @return a string key in the format "x:y".
     */
    private String getKey(int x, int y) {
        return x + ":" + y;
    }

    public Map<String,Node> getNodes() {
        return nodes;
    }
}

File path: java/org/example/Game/Board/Board.java:
package org.example.Game.Board;

import java.util.List;
import java.util.Map;

/**
 * Represents the game board.
 */
public interface Board {

    /**
     * Moves a peg from one position to another on the board.
     *
     * @param x1 the x-coordinate of the starting position.
     * @param y1 the y-coordinate of the starting position.
     * @param x2 the x-coordinate of the destination position.
     * @param y2 the y-coordinate of the destination position.
     */
    void movePeg(int x1, int y1, int x2, int y2);

    /**
     * Retrieves the node at the specified key.
     *
     * @param key the key representing the node in the format "x:y".
     * @return the {@link Node} object at the specified key, or null if the node does not exist.
     */
    Node getNode(String key);

    Map<String,Node> getNodes();

    /**
     * Checks if a node exists at the specified key.
     *
     * @param key the key representing the node in the format "x:y".
     * @return {@code true} if the node exists, {@code false} otherwise.
     */
    boolean containsNode(String key);


    List<String> getTargetBase(int player);

    boolean inTargetBase(int player, String key);
}

File path: java/org/example/Game/Board/StdBoard.java:
package org.example.Game.Board;

import java.util.*;

import static java.lang.Math.min;

/**
 * Represents a standard implementation of the game board.
 * This class manages the graph structure of the board, player positions, and base configurations.
 */
public class StdBoard implements Board {
    private final Graph graph;
    private final List<List<String>> bases;
    private final int players;

    /**
     * Constructs a standard board for the game with the specified number of players.
     *
     * @param players the number of players in the game.
     */
    public StdBoard(int players) {
        this.graph = new Graph();
        this.bases = new ArrayList<>();
        for(int i=0; i<6; i++) {
            bases.add(new ArrayList<>());
        }
        this.players = players;
        generate();
    }


    private void generate() {
        addNodes();
        addEdges();
        setBases();
        addPegs();
    }

    /**
     * Adds nodes to the board to represent positions.
     */
    private void addNodes() {
        for (int i = 0; i <= 3; i++) {
            for (int j = 4; j <= 4 + i; j++) {
                graph.addNode(i, j);
            }
        }

        for (int i = 4; i <= 8; i++) {
            for (int j = i - 4; j <= 12; j++) {
                graph.addNode(i, j);
            }
        }

        for (int i = 9; i <= 12; i++) {
            for (int j = 4; j <= 13 + i - 9; j++) {
                graph.addNode(i, j);
            }
        }

        for (int i = 13; i <= 16; i++) {
            for (int j = 9 - 13 + i; j <= 12; j++) {
                graph.addNode(i, j);
            }
        }
    }

    /**
     * Adds edges between nodes to define the connections on the board.
     */
    private void addEdges() {
        for (int i = 0; i < 17; i++) {
            for (int j = 0; j < 17; j++) {
                graph.addEdge(i, j, i, j + 1);
                graph.addEdge(i, j, i + 1, j + 1);
                graph.addEdge(i, j, i + 1, j);
            }
        }
    }


    private void setBases() {
        Collections.addAll(bases.get(0), "4:0", "4:1", "5:1", "4:2", "5:2", "6:2", "4:3", "5:3", "6:3", "7:3");
        Collections.addAll(bases.get(1), "9:4", "10:4", "10:5", "11:4", "11:5", "11:6", "12:4", "12:5", "12:6", "12:7");
        Collections.addAll(bases.get(2), "13:9", "13:10", "13:11", "13:12", "14:10", "14:11", "14:12", "15:11", "15:12", "16:12");
        Collections.addAll(bases.get(3), "9:13", "10:13", "10:14", "11:13", "11:14", "11:15", "12:13", "12:14", "12:15", "12:16");
        Collections.addAll(bases.get(4), "4:9", "4:10", "4:11", "4:12", "5:10", "5:11", "5:12", "6:11", "6:12", "7:12");
        Collections.addAll(bases.get(5), "0:4", "1:4", "1:5", "2:4", "2:5", "2:6", "3:4", "3:5", "3:6", "3:7");





    }

    private void addPegs() {
        int[] config = getStartConfiguration();
        for (int i = 0; i < config.length; i++) {
            for (String key : bases.get(config[i] - 1)) {
                graph.getNode(key).setPlayer(i + 1);
            }
        }
    }

    private int[] getStartConfiguration() {
        int[][] configurations = {
                {1, 4},
                {1, 3, 5},
                {1, 2, 4, 5},
                {1, 2, 3, 4, 5, 6}
        };

        return configurations[min(players-2, configurations.length-1)];
    }

    private int[] getTargetConfiguration() {
        int[][] configurations ={
                {4, 1},
                {4, 6, 2},
                {4, 5, 1, 2},
                {4, 5, 6, 1, 2, 3}
        };

        return configurations[min(players-2, configurations.length-1)];
    }

    @Override
    public Map<String,Node> getNodes() {
        return graph.getNodes();
    }

    @Override
    public void movePeg(int x1, int y1, int x2, int y2) {
        Node node1 = graph.getNode(x1+":"+y1);
        Node node2 = graph.getNode(x2+":"+y2);
        if(node1 != null && node2 !=null) {
            node2.setPlayer(node1.getPlayer());
            node1.setPlayer(0);
        }
    }

    @Override
    public Node getNode(String key) {
        return graph.getNode(key);
    }

    @Override
    public boolean containsNode(String key) {
        return graph.containsNode(key);
    }

    @Override
    public List<String> getTargetBase(int player) {
        int[] config = getTargetConfiguration();
        return bases.get(config[player-1] - 1);
    }

    @Override
    public boolean inTargetBase(int player, String key) {
        int[] config = getTargetConfiguration();
        if(player == 0) {
            return false;
        }
        int targetBase = config[player-1];
        if(bases.get(targetBase-1).contains(key)) {
            return true;
        }
        return false;
    };

}
File path: java/org/example/Game/GUI/CircleManager.java:
package org.example.Game.GUI;

import javafx.beans.value.ChangeListener;
import javafx.scene.control.Tooltip;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import org.example.Game.Board.Board;
import org.example.Game.Board.Node;

import java.util.ArrayList;
import java.util.List;


public class CircleManager {
    List<Circle> circles;
    private final int radius;

    public CircleManager() {
        circles = new ArrayList<>();
        radius = 12;
    }

    public void initializeCircles(Board board) {
        for(Node node : board.getNodes().values()) {
            Circle circle = new Circle();
            circle.setRadius(radius);
            circle.setCenterX(calculateXPos(node));
            circle.setCenterY(calculateYPos(node));
            initColors(circle, node);
            addNodeListener(circle, node);
            addTooltip(circle, node);

            circles.add(circle);
        }

    }

    private void initColors(Circle circle, Node node) {
        int player = node.getPlayer();
        switch (player) {
            case 1:
                circle.setFill(Color.BLUE);
                circle.setStroke(Color.BLUE);
                circle.setStrokeWidth(2);
                break;

            case 2:
                circle.setFill(Color.GREEN);
                circle.setStroke(Color.GREEN);
                circle.setStrokeWidth(2);
                break;

            case 3:
                circle.setFill(Color.PINK);
                circle.setStroke(Color.PINK);
                circle.setStrokeWidth(2);
                break;

            case 4:
                circle.setFill(Color.MEDIUMPURPLE);
                circle.setStroke(Color.MEDIUMPURPLE);
                circle.setStrokeWidth(2);
                break;

            case 5:
                circle.setFill(Color.RED);
                circle.setStroke(Color.RED);
                circle.setStrokeWidth(2);
                break;

            case 6:
                circle.setFill(Color.ORANGE);
                circle.setStroke(Color.ORANGE);
                circle.setStrokeWidth(2);
                break;

            default:
                circle.setFill(Color.GRAY);
                circle.setStroke(Color.BLACK);
                circle.setStrokeWidth(2);
                break;
        }

    }

    private int calculateXPos(Node node) {
        int nodeX = node.getX();
        int nodeY = node.getY();
        return 400 + (nodeX-4)*2*radius - nodeY*radius;
    }

    private int calculateYPos(Node node) {
        int nodeY = node.getY();
        return 100 + nodeY * 2 * radius;
    }

    private void addNodeListener(Circle circle, Node node) {
        ChangeListener<Number> playerChangeListener = (observable, oldValue, newValue) -> {
            switch (newValue.intValue()) {
                case 1 -> circle.setFill(Color.BLUE);
                case 2 -> circle.setFill(Color.GREEN);
                case 3 -> circle.setFill(Color.PINK);
                case 4 -> circle.setFill(Color.LAVENDER);
                case 5 -> circle.setFill(Color.RED);
                case 6 -> circle.setFill(Color.ORANGE);
                default -> circle.setFill(Color.GRAY);
            }
        };

        node.playerProperty().addListener(playerChangeListener);
    }

    private void addTooltip(Circle circle, Node node) {
        Tooltip tooltip = new Tooltip(node.getX()+":"+node.getY()+ " player: " + node.getPlayer());
        Tooltip.install(circle, tooltip);
        tooltip.setShowDelay(javafx.util.Duration.seconds(0.5));

        node.playerProperty().addListener((observable, oldValue, newValue) -> {
            tooltip.setText(node.getX() + ":" + node.getY() + " player: " + newValue.intValue());
        });
    }

    public List<Circle> getCircles() {
        return circles;
    }
}

File path: java/org/example/Game/GUI/BoardDisplay.java:
package org.example.Game.GUI;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.Pane;
import javafx.scene.shape.Circle;
import javafx.stage.Stage;
import org.example.Game.Board.Board;

public class BoardDisplay  extends Application {
    private static Board board;

    @Override
    public void start(Stage stage) throws Exception {
        Pane pane = new Pane();
        CircleManager circleManager = new CircleManager();
        circleManager.initializeCircles(board);

        for(Circle circle : circleManager.getCircles()) {
            pane.getChildren().add(circle);
        }

        Scene scene = new Scene(pane, 800, 600);
        stage.setScene(scene);
        stage.show();
    }

    public static void launchBoardDisplay(Board board) {
       BoardDisplay.board=board;

        launch();
    }

    public static void main(String[] args) {
        launch(args);
    }
}

File path: java/org/example/Game/GameState/WaitingForPlayers.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.Player;

/**
 * Represents the state of the game when waiting for players to join.
 */
public class WaitingForPlayers implements GameState {

    @Override
    public void handle(Game game) {
        if(game.getPlayers().size() == game.getMaxPlayers()) {
            game.broadcastMessage("Game full. Lets start.");
            game.setState(new GameStart());
            game.getState().handle(game);
        }
        else {
            game.broadcastMessage("Waiting for players. Player count: " + game.getPlayers().size());
        }
    }

    @Override
    public void addPlayer(Game game, Player player) {
        if(game.getPlayers().size() < game.getMaxPlayers()) {
            game.getPlayers().add(player);
            game.broadcastMessage("Added player number " + game.getPlayers().size()+ " " + player.getName());
        }
        else {
            game.broadcastMessage("Game is full, cannot add player.");
        }
        handle(game);
    }

    @Override
    public void play(Game game, int x1, int y1, int x2, int y2) {
        game.broadcastMessage("We are still waiting for players.");
    }
}

File path: java/org/example/Game/GameState/GameStart.java:
package org.example.Game.GameState;

import javafx.application.Application;
import org.example.Game.GUI.BoardDisplay;
import org.example.Game.Game;
import org.example.Game.Player;
import org.example.Server.States.UserState;

import java.util.Random;

/**
 * Represents the state of the game when it is about to start.
 */
public class GameStart implements GameState{

    @Override
    public void handle(Game game) {
        new Thread(() -> {
            BoardDisplay.launchBoardDisplay(game.getBoard());
        }).start();

        Random random = new Random();
        int startingPlayer = random.nextInt(game.getMaxPlayers());
        game.setCurrentPlayer(startingPlayer);
        game.broadcastMessage("Player: " + (startingPlayer+1) + " " + game.getPlayers().get(startingPlayer).getName() + " goes first.");
        game.setState(new GameOn());
        game.getState().handle(game);
    }

    @Override
    public void addPlayer(Game game, Player player) {
        game.broadcastMessage("Game is full. Cannot add new players.");
    }

    @Override
    public void play(Game game, int x1, int y1, int x2, int y2) {
        game.broadcastMessage("Game is not started yet.");
    }
}

File path: java/org/example/Game/GameState/GameOn.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.GameRules.GameRules;
import org.example.Game.Player;

/**
 * Represents the state of the game when it is actively being played.
 */
public class GameOn implements GameState {

    @Override
    public void handle(Game game) {
        game.broadcastMessage("Move of player: " + (game.getCurrentPlayer()+1) + " " + game.getPlayers().get(game.getCurrentPlayer()).getName());
    }

    @Override
    public void addPlayer(Game game, Player player) {
        System.out.println("Game is on. Cannot add player.");
    }

    @Override
    public void play(Game game, int x1, int y1, int x2, int y2) {
        GameRules rules = game.getRules();
        if(rules.isMoveValid(game.getBoard(), game.getCurrentPlayer()+1, x1,y1,x2,y2)) {
            game.getBoard().movePeg(x1,y1,x2,y2);
            game.broadcastMessage("Moved from " + x1 + ":" + y1 + " to " + x2 + ":" + y2);
            if(rules.checkForWin(game.getBoard(),game.getCurrentPlayer() + 1)) {
                game.setState(new GameOver(game.getCurrentPlayer() + 1));
                game.getState().handle(game);
            }
            else {
                game.endTurn();
                handle(game);
            }
        }
        else {
            game.broadcastMessage("This move is not valid. Your turn ends.");
            game.endTurn();
            handle(game);
        }
    }
}

File path: java/org/example/Game/GameState/GameOver.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.Player;

/**
 * Represents the state of the game when it has ended.
 */
public class GameOver implements GameState {
    int winner;

    /**
     * Constructs a new GameOver state with the specified winner.
     *
     * @param winner the index of the winning player
     */
    public GameOver(int winner) {
        this.winner = winner;
    }

    @Override
    public void handle(Game game) {
        game.broadcastMessage("PLAYER " + winner + ": " + game.getCurrentPlayer()+1 +" WON!!");
    }

    @Override
    public void addPlayer(Game game, Player player) {
        game.broadcastMessage("Cannot add players the game is over.");
    }

    @Override
    public void play(Game game, int x1, int y1, int x2, int y2) {
        game.broadcastMessage("Cannot move the game is over.");
    }
}

File path: java/org/example/Game/GameState/GameState.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.Player;

/**
 * Represents a state in the game lifecycle, defining behavior for adding players, making moves, and handling state transitions.
 */
public interface GameState {

    /**
     * Handles the current state logic.
     *
     * @param game the game instance
     */
    void handle(Game game);

    /**
     * Adds a player to the game in the current state.
     *
     * @param game   the game instance
     * @param player the player to add
     */
    void addPlayer(Game game, Player player);

    /**
     * Processes a move attempt in the current state.
     *
     * @param game the game instance
     * @param x1   the starting x-coordinate
     * @param y1   the starting y-coordinate
     * @param x2   the ending x-coordinate
     * @param y2   the ending y-coordinate
     */
    void play(Game game, int x1, int y1, int x2, int y2);
}

File path: java/org/example/Client/RunClient.java:
package org.example.Client;

import java.io.IOException;

/**
 * Entry point for the client application.
 */
public class RunClient {
    private static final String HOST = "localhost";
    private static final int PORT = 59899;

    public static void main(String[] args) {
        try {
            Client client = new Client(HOST, PORT);
            client.start();

        } catch (IOException e) {
            System.err.println("Failed to start the client: " + e.getMessage());
        }
    }
}

File path: java/org/example/Client/Client.java:
package org.example.Client;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

/**
 * A client program that connects to the server, sends commands, and displays server responses.
 */
public class Client {
    private Socket socket;
    private Scanner inputReader;
    private PrintWriter outputWriter;
    private Scanner userInputScanner;

    public Client(String host, int port) throws IOException {
        initializeSocket(host, port);
        initializeStreams();
    }

    /**
     * Initializes the socket connection to the server.
     */
    private void initializeSocket(String host, int port) throws IOException {
        try {
            socket = new Socket(host, port);
            System.out.println("Connected to the server at " + host + ":" + port);

        } catch (IOException e) {
            System.err.println("Unable to connect to the server: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Initializes the input and output streams for communication with the server.
     */
    private void initializeStreams() throws IOException {
        try {
            inputReader = new Scanner(socket.getInputStream());
            outputWriter = new PrintWriter(socket.getOutputStream(), true);
            userInputScanner = new Scanner(System.in);

        } catch (IOException e) {
            System.err.println("Error initializing I/O streams: " + e.getMessage());
            throw e;
        }
    }

    

    /**
     * Starts the client by initiating the listener thread and handling user input.
     */
    public void start() {
        // Start a thread to listen for messages from the server
        new Thread(new ServerListener()).start();

        // Main thread handles user input and sends commands to the server
        handleUserInput();
    }

    /**
     * Continuously reads user input and sends it to the server.
     */
    private void handleUserInput() {
        try {
            while (true) {
                if (userInputScanner.hasNextLine()) {
                    String userCommand = userInputScanner.nextLine();
                    outputWriter.println(userCommand);

                } else {
                    break; // Exit if no more input
                }
            }

        } catch (Exception e) {
            System.err.println("Error handling user input: " + e.getMessage());

        } finally {
            closeConnections();
        }
    }

    /**
     * Closes all connections and streams gracefully.
     */
    private void closeConnections() {
        try {
            if (socket != null && !socket.isClosed()) {
                socket.close();
            }

            if (userInputScanner != null) {
                userInputScanner.close();
            }

            if (inputReader != null) {
                inputReader.close();
            }

            if (outputWriter != null) {
                outputWriter.close();
            }

            System.out.println("Disconnected from the server.");

        } catch (IOException e) {
            System.err.println("Error closing connections: " + e.getMessage());
        }
    }

    /**
     * Inner class that listens for messages from the server and displays them.
     */
    private class ServerListener implements Runnable {
        @Override
        public void run() {
            try {
                while (inputReader.hasNextLine()) {
                    String serverMessage = inputReader.nextLine();
                    System.out.println(serverMessage);
                }

            } catch (Exception e) {
                System.err.println("Connection to server lost: " + e.getMessage());

            } finally {
                closeConnections();
            }
        }
    }
}
