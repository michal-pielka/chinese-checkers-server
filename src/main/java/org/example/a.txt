
File path: Server/UserSession.java:
package org.example.Server;

import org.example.Game.Game;
import org.example.Game.Player;
import org.example.Server.States.UserState;
import org.example.Server.States.LobbyState;
import org.example.Server.States.InGameState;

import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Encapsulates the game-related logic, state transitions, 
 * and user interactions (prompts) for a single connected user.
 */
public class UserSession {
    private final Server server;
    private final PrintWriter outputWriter;
    private final Scanner inputReader;
    private final Player player;

    // The user's current state (Lobby, InGame, etc.)
    private UserState state;

    // Flag to indicate if the session is active
    private volatile boolean active;

    /**
     * Constructor
     *
     * @param server       The server instance for game lookups, etc.
     * @param outputWriter A PrintWriter for sending messages to the client.
     * @param inputReader  A Scanner for reading user input.
     */
    public UserSession(Server server, PrintWriter outputWriter, Scanner inputReader) {
        this.server = server;
        this.outputWriter = outputWriter;
        this.inputReader = inputReader;
        this.state = new LobbyState(); // Initial state
        this.player = new Player("defaultName", outputWriter);
        this.active = true; // Session starts as active
    }

    /**
     * Handles the command from the client, delegating to the current state.
     *
     * @param clientInput The raw command string.
     */
    public void handleCommand(String clientInput) {
        System.out.println("Handling command: " + clientInput);
        state.handleCommand(this, clientInput);
    }

    /**
     * Sends a message to the client's console.
     *
     * @param message The message to send.
     */
    public void sendMessage(String message) {
        outputWriter.println(message);
        System.out.println("Sent message to " + player.getName() + ": " + message);
    }

    /**
     * Updates the user's state.
     *
     * @param newState The new state to set.
     */
    public void setState(UserState newState) {
        System.out.println("Transitioning user " + player.getName() + " from " 
                           + state.getClass().getSimpleName() + " to " 
                           + newState.getClass().getSimpleName());
        this.state = newState;
    }

    /**
     * Gets the currently logged-in Player instance.
     */
    public Player getPlayer() {
        return player;
    }

    /**
     * Gets the Server reference for game lookups, game creation, etc.
     */
    public Server getServer() {
        return server;
    }

    /**
     * Gets the current state of the user.
     */
    public UserState getState() {
        return this.state;
    }

    // ----------------------------------------------------------------------
    // Methods to facilitate user interactions (now called by Command classes)
    // ----------------------------------------------------------------------

    public String askForLobbyName() {
        String lobbyName = null;
        while (lobbyName == null || lobbyName.isEmpty()) {
            sendMessage("Please input your lobby name:");
            if (inputReader.hasNextLine()) {
                lobbyName = inputReader.nextLine().trim();
                if (lobbyName.isEmpty()) {
                    sendMessage("Lobby name cannot be empty.");
                    System.out.println("User " + player.getName() + " entered an empty lobby name.");
                }
            } else {
                lobbyName = "default_lobby";
                System.out.println("No lobby name input detected. Defaulting to 'default_lobby'.");
            }
        }
        return lobbyName;
    }

    /**
     * Sends the initial welcome/help menu to the client.
     */
    public void displayStartMenu() {
        sendMessage("Welcome! Use one of the following commands: join, create, list, quit");
    }

    public int askForNumberOfPlayers() {
        int number = 0;
        while (number != 2 && number != 3 && number != 4 && number != 6) {
            sendMessage("Please input number of players (2, 3, 4, or 6):");
            if (inputReader.hasNextLine()) {
                String response = inputReader.nextLine().trim();
                try {
                    number = Integer.parseInt(response);
                    if (number != 2 && number != 3 && number != 4 && number != 6) {
                        sendMessage("Invalid number of players. Choose 2, 3, 4, or 6.");
                        System.out.println("User " + player.getName() + " entered invalid number of players: " + number);
                    }
                } catch (NumberFormatException e) {
                    sendMessage("Invalid input. Please enter a numeric value.");
                    System.out.println("User " + player.getName() + " entered non-numeric input for number of players.");
                }
            } else {
                // Fallback
                sendMessage("No input detected. Defaulting to 2 players.");
                number = 2;
                System.out.println("No input detected for number of players. Defaulting to 2.");
            }
        }
        return number;
    }

    public String askForPlayerName() {
        String playerName = null;
        while (playerName == null || playerName.isEmpty()) {
            sendMessage("Please input your player name:");
            if (inputReader.hasNextLine()) {
                playerName = inputReader.nextLine().trim();
                if (playerName.isEmpty()) {
                    sendMessage("Player name cannot be empty.");
                    System.out.println("User " + player.getName() + " entered an empty player name.");
                }
            } else {
                playerName = "Anonymous";
                System.out.println("No player name input detected. Defaulting to 'Anonymous'.");
            }
        }
        return playerName;
    }

    /**
     * Signals the session to terminate.
     */
    public void terminate() {
        this.active = false;
        System.out.println("Session for user " + player.getName() + " is marked for termination.");
    }

    /**
     * Checks if the session is active.
     *
     * @return True if active, false otherwise.
     */
    public boolean isActive() {
        return active;
    }
}

File path: Server/UserThread.java:
package org.example.Server;

import java.io.IOException;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

/**
 * Handles communication with a single client.
 */
public class UserThread implements Runnable {
    private final Socket socket;
    private final Server server;
    private Scanner inputReader;
    private PrintWriter outputWriter;

    private UserSession userSession;
    private final UserManager userManager;

    /**
     * Constructor to initialize client socket and server reference.
     *
     * @param socket The client socket.
     * @param server The server instance managing games.
     */
    public UserThread(Socket socket, Server server) {
        this.socket = socket;
        this.server = server;
        this.userManager = new UserManager(server);

        try {
            initializeStreams();
            this.userSession = userManager.createUserSession(outputWriter, inputReader);

        } catch (IOException e) {
            System.err.println("Error initializing I/O streams for client " + socket + ": " + e.getMessage());
            closeSocket();
        }
    }

    /**
     * Initializes the input and output streams for communication with the client.
     *
     * @throws IOException If an I/O error occurs.
     */
    private void initializeStreams() throws IOException {
        inputReader = new Scanner(socket.getInputStream());
        outputWriter = new PrintWriter(socket.getOutputStream(), true);
    }

    /**
     * Entry point for the user thread.
     */
    @Override
    public void run() {
        System.out.println("Connected: " + socket);

        try {
            userSession.displayStartMenu();

            while (inputReader.hasNextLine()) {
                String clientInput = inputReader.nextLine().trim();
                System.out.println("Received from " + socket + ": " + clientInput);

                userSession.handleCommand(clientInput);
            }

        } catch (Exception e) {
            System.err.println("Error communicating with client " + socket + ": " + e.getMessage());

        } finally {
            closeSocket();
            System.out.println("Closed: " + socket);
        }
    }

    /**
     * Closes the client socket gracefully.
     */
    private void closeSocket() {
        try {
            if (socket != null && !socket.isClosed()) {
                socket.close();
            }
        } catch (IOException e) {
            System.err.println("Error closing socket " + socket + ": " + e.getMessage());
        }
    }
}

File path: Server/UserManager.java:
// File path: src/main/java/org/example/Server/UserManager.java
package org.example.Server;

import java.io.PrintWriter;
import java.util.Scanner;

/**
 * Manages user sessions, creation, and related functionalities.
 */
public class UserManager {
    private final Server server;

    /**
     * Constructor to initialize the UserManager with a reference to the Server.
     *
     * @param server The server instance managing games.
     */
    public UserManager(Server server) {
        this.server = server;
    }

    /**
     * Creates a new UserSession.
     *
     * @param outputWriter The PrintWriter to send messages to the client.
     * @param inputReader  The Scanner to read user input.
     * @return A new UserSession instance.
     */
    public UserSession createUserSession(PrintWriter outputWriter, Scanner inputReader) {
        return new UserSession(server, outputWriter, inputReader);
    }

    // Additional management methods can be added here if needed in the future
}

File path: Server/Server.java:
package org.example.Server;

import org.example.Game.Game;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Encapsulates the core server logic.
 */
public class Server {
    private int port;
    private int threadPoolSize;
    private ExecutorService pool;
    private final List<Game> games;

    /**
     * Constructor to initialize server settings.
     *
     * @param port            The port on which the server listens.
     * @param threadPoolSize  The number of threads in the pool.
     */
    public Server(int port, int threadPoolSize) {
        this.port = port;
        this.threadPoolSize = threadPoolSize;
        this.pool = Executors.newFixedThreadPool(threadPoolSize);
        // Initialize a thread-safe list for games
        this.games = Collections.synchronizedList(new ArrayList<>());
    }

    /**
     * Starts the server to listen for client connections.
     *
     * @throws IOException If an I/O error occurs when opening the socket.
     */
    public void start() throws IOException {
        System.out.println("Server is running on port " + port + "...");

        try (ServerSocket serverSocket = new ServerSocket(port)) {
            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("New client connected: " + clientSocket);

                // Pass the server reference to UserThread
                UserThread user = new UserThread(clientSocket, this);
                pool.execute(user);
            }

        } finally {
            shutdownPool();
        }
    }

    /**
     * Shuts down the thread pool gracefully.
     */
    private void shutdownPool() {
        if (pool != null && !pool.isShutdown()) {
            pool.shutdown();
            System.out.println("Server thread pool shut down.");
        }
    }

    /**
     * Finds a game by its lobby name (case-insensitive).
     *
     * @param lobbyName The name of the lobby to find.
     * @return The Game object if found; otherwise, null.
     */
    public Game findGameByName(String lobbyName) {
        synchronized (games) {
            for (Game game : games) {
                if (game.getLobbyName().equalsIgnoreCase(lobbyName)) {
                    return game;
                }
            }
        }
        return null;
    }

    /**
     * Adds a new game to the list.
     *
     * @param game The Game object to add.
     */
    public void addGame(Game game) {
        synchronized (games) {
            games.add(game);
            System.out.println("Game added: " + game.getLobbyName());
        }
    }

    /**
     * Retrieves an unmodifiable list of current games.
     *
     * @return A list of Game objects.
     */
    public List<Game> getGames() {
        synchronized (games) {
            return Collections.unmodifiableList(new ArrayList<>(games));
        }
    }

    /**
     * Removes a game from the list.
     *
     * @param game The Game object to remove.
     */
    public void removeGame(Game game) {
        synchronized (games) {
            games.remove(game);
            System.out.println("Game removed: " + game.getLobbyName());
        }
    }
}

File path: Server/RunServer.java:
package org.example.Server;

import java.io.IOException;

/**
 * Entry point for the server application.
 */
public class RunServer {
    private static final int PORT = 59899;
    private static final int THREAD_POOL_SIZE = 20; // Adjust based on expected load

    public static void main(String[] args) {
        try {
            Server server = new Server(PORT, THREAD_POOL_SIZE);
            server.start();

        } catch (IOException e) {
            System.err.println("Failed to start the server: " + e.getMessage());
        }
    }
}

File path: Server/States/InGameState.java:
// File path: src/main/java/org/example/Server/States/InGameState.java
package org.example.Server.States;

import org.example.Server.UserSession;
import org.example.Game.Game;
import org.example.Server.Commands.CommandRegistry;
import org.example.Server.Commands.Command;
import org.example.Server.Commands.CommandConstants;

import java.util.HashMap;

public class InGameState extends UserState {
    private Game game;
    private CommandRegistry registry;

    public InGameState(Game game) {
        this.game = game;
        this.registry = new CommandRegistry();
        this.commands = new HashMap<>();

        commands.put(CommandConstants.MOVE, registry.getCommand(CommandConstants.MOVE));
    }

    @Override
    public void handleCommand(UserSession session, String commandLine) {
        String[] tokens = commandLine.split("\\s+");
        String commandName = tokens[0].toLowerCase();
        Command command = commands.get(commandName);

        if (command != null) {
            command.execute(session, tokens);

        } else {
            session.sendMessage("Invalid command in Game. Available commands: move");
        }
    }

    public Game getGame() {
        return this.game;
    }
}

File path: Server/States/UserState.java:
package org.example.Server.States;

import org.example.Server.UserSession;
import org.example.Server.Commands.Command;

import java.util.HashMap;

public abstract class UserState {
    protected HashMap<String, Command> commands;

    public abstract void handleCommand(UserSession session, String commandLine);
}

File path: Server/States/LobbyState.java:
// File path: src/main/java/org/example/Server/States/LobbyState.java
package org.example.Server.States;

import org.example.Server.UserSession;
import org.example.Server.Commands.CommandRegistry;
import org.example.Server.Commands.Command;
import org.example.Server.Commands.CommandConstants;

import java.util.HashMap;

public class LobbyState extends UserState {
    private CommandRegistry registry;

    public LobbyState() {
        this.registry = new CommandRegistry();
        this.commands = new HashMap<>();

        // Load lobby-specific commands using constants
        commands.put(CommandConstants.JOIN, registry.getCommand(CommandConstants.JOIN));
        commands.put(CommandConstants.CREATE, registry.getCommand(CommandConstants.CREATE));
        commands.put(CommandConstants.LIST, registry.getCommand(CommandConstants.LIST));
        commands.put(CommandConstants.QUIT, registry.getCommand(CommandConstants.QUIT));
    }

    @Override
    public void handleCommand(UserSession session, String commandLine) {
        String[] tokens = commandLine.split("\\s+");
        String commandName = tokens[0].toLowerCase();
        Command command = commands.get(commandName);
        if (command != null) {
            command.execute(session, tokens);
        } else {
            session.sendMessage("Invalid command in Lobby. Available commands: join, create, list, quit");
        }
    }
}

File path: Server/Commands/CreateCommand.java:
package org.example.Server.Commands;

import org.example.Game.Game;
import org.example.Server.States.InGameState;
import org.example.Server.UserSession;

public class CreateCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        System.out.println("User " + session.getPlayer().getName() + " chose to create a game.");
        session.sendMessage("You chose to create a game.");

        String lobbyName = session.askForLobbyName();
        if (session.getServer().findGameByName(lobbyName) != null) {
            session.sendMessage("A game with lobby name '" + lobbyName + "' already exists. Try a different name.");
            System.out.println("User " + session.getPlayer().getName() + " attempted to create a lobby with existing name '" + lobbyName + "'.");
            return;
        }

        int maxPlayers = session.askForNumberOfPlayers();
        Game game = new Game(lobbyName, maxPlayers);

        session.getServer().addGame(game);
        System.out.println("User " + session.getPlayer().getName() + " created game '" + lobbyName + "', max players: " + maxPlayers);

        String playerName = session.askForPlayerName();
        session.getPlayer().setName(playerName);
        System.out.println("User set name to " + playerName);

        game.addPlayer(session.getPlayer());
        game.broadcastMessage(session.getPlayer().getName() + " has created and joined the game.");
        System.out.println("User " + session.getPlayer().getName() + " joined their own created game '" + lobbyName + "'.");

        // Switch to InGameState
        session.setState(new InGameState(game));
    }
}

File path: Server/Commands/JoinCommand.java:
package org.example.Server.Commands;

import org.example.Game.Game;
import org.example.Server.States.InGameState;
import org.example.Server.UserSession;

public class JoinCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        System.out.println("User " + session.getPlayer().getName() + " chose to join a game.");
        session.sendMessage("You chose to join a game.");

        String playerName = session.askForPlayerName();
        session.getPlayer().setName(playerName);
        System.out.println("User set name to " + playerName);

        // Attempt to find the requested lobby
        Game game = null;
        while (game == null) {
            String lobbyName = session.askForLobbyName();
            game = session.getServer().findGameByName(lobbyName);
            if (game == null) {
                session.sendMessage("Cannot find game with lobby name '" + lobbyName + "'. Try again.");
                System.out.println("User " + session.getPlayer().getName() + " attempted to join non-existent lobby '" + lobbyName + "'.");
            }
        }

        // Join the game
        synchronized (game) {
            if (game.getPlayers().size() >= game.getMaxPlayers()) {
                session.sendMessage("Game '" + game.getLobbyName() + "' is full. Choose another game.");
                System.out.println("User " + session.getPlayer().getName() + " attempted to join full lobby '" + game.getLobbyName() + "'.");
                return;
            }
            game.addPlayer(session.getPlayer());
            game.broadcastMessage(session.getPlayer().getName() + " has joined the game.");
            System.out.println("User " + session.getPlayer().getName() + " joined game '" + game.getLobbyName() + "'.");

            // Transition to InGameState
            session.setState(new InGameState(game));
        }
    }
}

File path: Server/Commands/ListGamesCommand.java:
package org.example.Server.Commands;

import org.example.Server.UserSession;
import org.example.Game.Game;

import java.util.List;

public class ListGamesCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        System.out.println("User " + session.getPlayer().getName() + " requested to list available games.");
        List<Game> currentGames = session.getServer().getGames();
        
        if (currentGames.isEmpty()) {
            session.sendMessage("No available games to join. You can create one using the 'create' command.");
            System.out.println("No available games found for user " + session.getPlayer().getName() + ".");
        } else {
            session.sendMessage("Available Games:");
            for (Game g : currentGames) {
                session.sendMessage("- " + g.getLobbyName() + " (" 
                                    + g.getPlayers().size() + "/" 
                                    + g.getMaxPlayers() + " players)");
            }
            System.out.println("Listed " + currentGames.size() + " available games to user " + session.getPlayer().getName() + ".");
        }
    }
}

File path: Server/Commands/Command.java:
package org.example.Server.Commands;

import org.example.Server.UserSession;

public interface Command {
    void execute(UserSession session, String[] args);
}

File path: Server/Commands/QuitCommand.java:
package org.example.Server.Commands;

import org.example.Server.UserSession;

/**
 * Handles the 'quit' command, allowing the user to disconnect gracefully.
 */
public class QuitCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        System.out.println("User " + session.getPlayer().getName() + " is disconnecting.");
        session.sendMessage("Disconnecting from the server. Goodbye!");

        // Signal the session to terminate
        session.terminate();
    }
}

File path: Server/Commands/CommandRegistry.java:
package org.example.Server.Commands;

import java.util.HashMap;
import java.util.Map;

public class CommandRegistry {
    private Map<String, Command> commands = new HashMap<>();

    public CommandRegistry() {
        register(CommandConstants.JOIN, new JoinCommand());
        register(CommandConstants.CREATE, new CreateCommand());
        register(CommandConstants.LIST, new ListGamesCommand());
        register(CommandConstants.QUIT, new QuitCommand());
        register(CommandConstants.MOVE, new MoveCommand());
    }

    public void register(String commandName, Command command) {
        commands.put(commandName, command);
    }

    public Command getCommand(String commandName) {
        return commands.get(commandName);
    }
}

File path: Server/Commands/CommandConstants.java:
package org.example.Server.Commands;

/**
 * Holds all command string constants used in the server.
 */
public class CommandConstants {
    public static final String CREATE = "create";
    public static final String JOIN = "join";
    public static final String LIST = "list";
    public static final String QUIT = "quit";
    public static final String MOVE = "move";
}

File path: Server/Commands/MoveCommand.java:
package org.example.Server.Commands;

import org.example.Server.UserSession;
import org.example.Game.Game;

public class MoveCommand implements Command {
    @Override
    public void execute(UserSession session, String[] args) {
        if (args.length != 3) {
            session.sendMessage("Usage: move <startPos> <endPos>");
            return;
        }
        try {
            int startPos = Integer.parseInt(args[1]);
            int endPos = Integer.parseInt(args[2]);
            Game game = ((org.example.Server.States.InGameState) session.getState()).getGame();
            game.move(session.getPlayer(), startPos, endPos);
        } catch (NumberFormatException e) {
            session.sendMessage("Start and End positions should be integers.");
        } catch (ClassCastException e) {
            session.sendMessage("Invalid game state for moving.");
            System.out.println("User " + session.getPlayer().getName() + " attempted to move in an invalid state.");
        }
    }
}

File path: Game/Player.java:
package org.example.Game;

import java.io.PrintWriter;

public class Player {
    private PrintWriter outputWriter;
    private String playerName;

    public Player(String name, PrintWriter writer) {
        this.playerName = name;
        this.outputWriter = writer;
    }

    public void sendMessage(String message) {
        outputWriter.println(message);
    }

    public String getName() {
        return playerName;
    }

    public void setName(String name) {this.playerName = name;}
}

File path: Game/Game.java:
package org.example.Game;

import org.example.Game.GameState.GameState;
import org.example.Game.GameState.WaitingForPlayers;
import java.util.ArrayList;

public class Game {
    String lobbyName;
    ArrayList<Player> players;
    int currentPlayer;
    int maxPlayers;
    Board board;
    GameState state;

    public Game(String name, int playerCount) {
        this.lobbyName = name;
        this. maxPlayers = playerCount;
        players = new ArrayList<>();
        board = null; // Do poprawy!!!
        state = new WaitingForPlayers();
        currentPlayer = 0;
    }
    public String getLobbyName() {
        return lobbyName;
    }
    public ArrayList<Player> getPlayers() {
        return players;
    }

    public int getCurrentPlayer() {
        return currentPlayer;
    }

    public void setCurrentPlayer(int i) {
        this.currentPlayer = i % this.maxPlayers;
    }

    public int getMaxPlayers() {
        return maxPlayers;
    }

    public void setState(GameState state) {
        this.state = state;
    }

    public GameState getState() {
        return state;
    }

    public void addPlayer(Player player) {
        state.addPlayer(this, player);
    }

    public void broadcastMessage(String message) {
        for(Player player : players) {
            player.sendMessage(message);
        }
    }

    public void move(Player player, int startPos, int endPos) {
        if(players.get(currentPlayer) != player) {
            player.sendMessage("Not your turn.");
        }
        else {
            state.play(this, startPos, endPos);
        }
    }

    public void endTurn() {
        currentPlayer=(currentPlayer + 1) % maxPlayers;
    }
}

File path: Game/Board.java:
package org.example.Game;

public interface Board {
}

File path: Game/StdBoard.java:
package org.example.Game;

public class StdBoard implements Board{
}

File path: Game/GameState/WaitingForPlayers.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.Player;

public class WaitingForPlayers implements GameState {

    @Override
    public void handle(Game game) {
        if(game.getPlayers().size() == game.getMaxPlayers()) {
            game.broadcastMessage("Game full. Lets start.");
            game.setState(new GameStart());
            game.getState().handle(game);
        }
        else {
            game.broadcastMessage("Waiting for players. Player count: " + game.getPlayers().size());
        }
    }

    @Override
    public void addPlayer(Game game, Player player) {
        if(game.getPlayers().size() < game.getMaxPlayers()) {
            game.getPlayers().add(player);
            game.broadcastMessage("Added player number " + game.getPlayers().size()+ " " + player.getName());
        }
        else {
            game.broadcastMessage("Game is full, cannot add player.");
        }
        handle(game);
    }

    @Override
    public void play(Game game, int startPos, int endPos) {
        game.broadcastMessage("We are still waiting for players.");
    }
}

File path: Game/GameState/GameStart.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.Player;

import java.util.Random;

public class GameStart implements GameState{

    @Override
    public void handle(Game game) {
        Random random = new Random();
        int startingPlayer = random.nextInt(game.getMaxPlayers());
        game.setCurrentPlayer(startingPlayer);
        game.broadcastMessage("Player: " + (startingPlayer+1) + " " + game.getPlayers().get(startingPlayer).getName() + " goes first.");
        game.setState(new GameOn());
        game.getState().handle(game);
    }

    @Override
    public void addPlayer(Game game, Player player) {
        game.broadcastMessage("Game is full. Cannot add new players.");
    }

    @Override
    public void play(Game game, int startPos, int endPos) {
        game.broadcastMessage("Game is not started yet.");
    }
}

File path: Game/GameState/GameOn.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.Player;

public class GameOn implements GameState {

    @Override
    public void handle(Game game) {
        game.broadcastMessage("Move of player: " + (game.getCurrentPlayer()+1) + " " + game.getPlayers().get(game.getCurrentPlayer()).getName());
    }

    @Override
    public void addPlayer(Game game, Player player) {
        System.out.println("Game is on. Cannot add player.");
    }

    @Override
    public void play(Game game, int startPos, int endPos) {
        game.broadcastMessage("Moved from " + startPos + " to " + endPos);
        game.endTurn();
        handle(game);
    }
}

File path: Game/GameState/GameOver.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.Player;

public class GameOver implements GameState {

    @Override
    public void handle(Game game) {

    }

    @Override
    public void addPlayer(Game game, Player player) {

    }

    @Override
    public void play(Game game, int starPos, int endPos) {

    }
}

File path: Game/GameState/GameState.java:
package org.example.Game.GameState;

import org.example.Game.Game;
import org.example.Game.Player;

public interface GameState {
    void handle(Game game);
    void addPlayer(Game game, Player player);
    void play(Game game, int startPos, int endPos);
}

File path: Client/RunClient.java:
package org.example.Client;

import java.io.IOException;

/**
 * Entry point for the client application.
 */
public class RunClient {
    private static final String HOST = "localhost";
    private static final int PORT = 59899;

    public static void main(String[] args) {
        try {
            Client client = new Client(HOST, PORT);
            client.start();

        } catch (IOException e) {
            System.err.println("Failed to start the client: " + e.getMessage());
        }
    }
}

File path: Client/Client.java:
package org.example.Client;

import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

/**
 * A client program that connects to the server, sends commands, and displays server responses.
 */
public class Client {
    private Socket socket;
    private Scanner inputReader;
    private PrintWriter outputWriter;
    private Scanner userInputScanner;

    public Client(String host, int port) throws IOException {
        initializeSocket(host, port);
        initializeStreams();
    }

    /**
     * Initializes the socket connection to the server.
     */
    private void initializeSocket(String host, int port) throws IOException {
        try {
            socket = new Socket(host, port);
            System.out.println("Connected to the server at " + host + ":" + port);

        } catch (IOException e) {
            System.err.println("Unable to connect to the server: " + e.getMessage());
            throw e;
        }
    }

    /**
     * Initializes the input and output streams for communication with the server.
     */
    private void initializeStreams() throws IOException {
        try {
            inputReader = new Scanner(socket.getInputStream());
            outputWriter = new PrintWriter(socket.getOutputStream(), true);
            userInputScanner = new Scanner(System.in);

        } catch (IOException e) {
            System.err.println("Error initializing I/O streams: " + e.getMessage());
            throw e;
        }
    }

    

    /**
     * Starts the client by initiating the listener thread and handling user input.
     */
    public void start() {
        // Start a thread to listen for messages from the server
        new Thread(new ServerListener()).start();

        // Main thread handles user input and sends commands to the server
        handleUserInput();
    }

    /**
     * Continuously reads user input and sends it to the server.
     */
    private void handleUserInput() {
        try {
            while (true) {
                if (userInputScanner.hasNextLine()) {
                    String userCommand = userInputScanner.nextLine();
                    outputWriter.println(userCommand);

                } else {
                    break; // Exit if no more input
                }
            }

        } catch (Exception e) {
            System.err.println("Error handling user input: " + e.getMessage());

        } finally {
            closeConnections();
        }
    }

    /**
     * Closes all connections and streams gracefully.
     */
    private void closeConnections() {
        try {
            if (socket != null && !socket.isClosed()) {
                socket.close();
            }

            if (userInputScanner != null) {
                userInputScanner.close();
            }

            if (inputReader != null) {
                inputReader.close();
            }

            if (outputWriter != null) {
                outputWriter.close();
            }

            System.out.println("Disconnected from the server.");

        } catch (IOException e) {
            System.err.println("Error closing connections: " + e.getMessage());
        }
    }

    /**
     * Inner class that listens for messages from the server and displays them.
     */
    private class ServerListener implements Runnable {
        @Override
        public void run() {
            try {
                while (inputReader.hasNextLine()) {
                    String serverMessage = inputReader.nextLine();
                    System.out.println(serverMessage);
                }

            } catch (Exception e) {
                System.err.println("Connection to server lost: " + e.getMessage());

            } finally {
                closeConnections();
            }
        }
    }
}
